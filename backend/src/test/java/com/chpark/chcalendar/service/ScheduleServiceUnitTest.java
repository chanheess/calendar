package com.chpark.chcalendar.service;import com.chpark.chcalendar.dto.schedule.ScheduleDto;import com.chpark.chcalendar.dto.schedule.ScheduleNotificationDto;import com.chpark.chcalendar.dto.schedule.ScheduleRepeatDto;import com.chpark.chcalendar.entity.schedule.ScheduleEntity;import com.chpark.chcalendar.entity.UserEntity;import com.chpark.chcalendar.entity.schedule.ScheduleRepeatEntity;import com.chpark.chcalendar.enumClass.ScheduleRepeatType;import com.chpark.chcalendar.repository.schedule.ScheduleNotificationRepository;import com.chpark.chcalendar.repository.schedule.ScheduleRepeatRepository;import com.chpark.chcalendar.repository.schedule.ScheduleRepository;import com.chpark.chcalendar.service.calendar.UserCalendarService;import com.chpark.chcalendar.service.user.GroupUserService;import com.chpark.chcalendar.service.schedule.ScheduleNotificationService;import com.chpark.chcalendar.service.schedule.ScheduleRepeatService;import com.chpark.chcalendar.service.schedule.ScheduleService;import jakarta.persistence.EntityNotFoundException;import org.junit.jupiter.api.BeforeEach;import org.junit.jupiter.api.Test;import org.junit.jupiter.api.extension.ExtendWith;import org.junit.jupiter.params.ParameterizedTest;import org.junit.jupiter.params.provider.CsvSource;import org.mockito.InjectMocks;import org.mockito.Mock;import org.mockito.junit.jupiter.MockitoExtension;import java.time.LocalDateTime;import java.util.List;import java.util.Optional;import java.util.Set;import static org.assertj.core.api.AssertionsForInterfaceTypes.assertThat;import static org.junit.jupiter.api.Assertions.*;import static org.mockito.ArgumentMatchers.any;import static org.mockito.Mockito.*;@ExtendWith(MockitoExtension.class)class ScheduleServiceUnitTest {    @Mock    private ScheduleRepository scheduleRepository;    @Mock    private ScheduleNotificationRepository scheduleNotificationRepository;    @Mock    private ScheduleRepeatRepository scheduleRepeatRepository;    @Mock    private ScheduleNotificationService scheduleNotificationService;    @Mock    private ScheduleRepeatService scheduleRepeatService;    @Mock    private GroupUserService groupUserService;    @Mock    private UserCalendarService userCalendarService;    @InjectMocks    private ScheduleService scheduleService;    private UserEntity mockUser;    private ScheduleEntity mockSchedule;    ScheduleDto.Request mockRequestDto;    @BeforeEach    void setup() {        // 유저 및 일정 기본값 설정        mockUser = UserEntity.builder()                .id(1)                .email("test@example.com")                .build();        mockSchedule = new ScheduleEntity();        mockSchedule.setId(1);        mockSchedule.setTitle("Test Schedule");        mockSchedule.setUserId(mockUser.getId());        mockSchedule.setStartAt(LocalDateTime.now());        mockSchedule.setEndAt(LocalDateTime.now().plusDays(1));        mockSchedule.setRepeatId(null);        mockSchedule.setCalendarId(1);        mockRequestDto = new ScheduleDto.Request();        ScheduleDto scheduleDto = new ScheduleDto();        scheduleDto.setTitle("Test Form Schedule");        scheduleDto.setDescription("Form Desc");        scheduleDto.setStartAt(LocalDateTime.now());        scheduleDto.setEndAt(LocalDateTime.now().plusDays(1));        scheduleDto.setCalendarId(1);        ScheduleNotificationDto notificationDto = new ScheduleNotificationDto();        notificationDto.setNotificationAt(LocalDateTime.now().plusHours(1));        ScheduleRepeatDto repeatDto = new ScheduleRepeatDto();        repeatDto.setRepeatType(ScheduleRepeatType.DAY);        repeatDto.setRepeatInterval(1);        mockRequestDto.setScheduleDto(scheduleDto);        mockRequestDto.setNotificationDto(Set.of(notificationDto));        mockRequestDto.setRepeatDto(repeatDto);    }    @Test    void create() {        when(scheduleRepository.save(any(ScheduleEntity.class)))                .thenAnswer(invocation -> invocation.<ScheduleEntity>getArgument(0));        ScheduleDto createdSchedule = scheduleService.create(mockRequestDto.getScheduleDto(), mockUser.getId());        assertNotNull(createdSchedule);        assertEquals("Test Form Schedule", createdSchedule.getTitle());    }    @Test    void findSchedulesByTitle() {        when(scheduleRepository.findByTitleContainingAndUserId("Test", mockUser.getId()))                .thenReturn(List.of(mockSchedule));        List<ScheduleDto> result = scheduleService.findSchedulesByTitle("Test", mockUser.getId());        assertFalse(result.isEmpty(), "Result should not be empty");        assertEquals("Test Schedule", result.get(0).getTitle(), "Schedule title should be 'Test Schedule'");    }    @Test    void update() {        when(scheduleRepository.findById(mockSchedule.getId()))                .thenReturn(Optional.of(mockSchedule));        ScheduleDto scheduleDto = new ScheduleDto();        scheduleDto.setStartAt(LocalDateTime.now());        scheduleDto.setEndAt(LocalDateTime.now().plusDays(1));        scheduleDto.setTitle("Updated Schedule");        when(scheduleRepository.save(any(ScheduleEntity.class)))                .thenAnswer(invocation -> invocation.<ScheduleEntity>getArgument(0));        ScheduleDto updatedSchedule = scheduleService.update(mockSchedule.getId(), scheduleDto, mockUser.getId());        assertEquals("Updated Schedule", updatedSchedule.getTitle());    }    @Test    void deleteById() {        when(scheduleRepository.getRepeatId(mockSchedule.getId(), mockUser.getId()))                .thenReturn(Optional.empty());        doNothing().when(scheduleNotificationRepository).deleteByScheduleId(mockSchedule.getId());        doNothing().when(scheduleRepository).deleteByIdAndUserId(mockSchedule.getId(), mockUser.getId());        when(scheduleRepository.findById(mockSchedule.getId()))                .thenReturn(Optional.empty());        assertDoesNotThrow(() -> scheduleService.deleteById(mockSchedule.getId(), mockSchedule.getCalendarId(), mockUser.getId()));        verify(scheduleRepository, times(1)).deleteByIdAndUserId(mockSchedule.getId(), mockUser.getId());        Optional<ScheduleEntity> deletedSchedule = scheduleRepository.findById(mockSchedule.getId());        assertTrue(deletedSchedule.isEmpty(), "The schedule should no longer exist after deletion");    }    @Test    void deleteCurrentOnlyRepeatSchedule() {        // Given        long scheduleId = mockSchedule.getId();        long userId = mockUser.getId();        long repeatId = 1;        mockSchedule.setRepeatId(repeatId);        when(scheduleRepository.findByIdAndUserId(scheduleId, userId))                .thenReturn(Optional.of(mockSchedule));        when(scheduleRepository.isLastRemainingRepeatSchedule(repeatId))                .thenReturn(true);        doNothing().when(scheduleRepeatRepository).deleteById(repeatId);        // When        scheduleService.deleteCurrentOnlyRepeatSchedule(scheduleId, userId);        // Then        verify(scheduleRepository).findByIdAndUserId(scheduleId, userId);        verify(scheduleRepository).isLastRemainingRepeatSchedule(repeatId);        verify(scheduleRepeatRepository).deleteById(repeatId);    }    @Test    void deleteCurrentOnlyRepeatSchedule_ScheduleNotFound() {        // Given        long scheduleId = mockSchedule.getId();        long userId = mockUser.getId();        when(scheduleRepository.findByIdAndUserId(scheduleId, userId))                .thenReturn(Optional.empty());        assertThrows(EntityNotFoundException.class,                () -> scheduleService.deleteCurrentOnlyRepeatSchedule(scheduleId, userId));        verify(scheduleRepository).findByIdAndUserId(scheduleId, userId);        verifyNoMoreInteractions(scheduleRepository, scheduleRepeatRepository);    }    @Test    void deleteCurrentOnlyRepeatSchedule_changeMaster() {        // Given        long scheduleId = mockSchedule.getId();        long userId = mockUser.getId();        long repeatId = 1L;        mockSchedule.setRepeatId(repeatId);        when(scheduleRepository.findByIdAndUserId(scheduleId, userId))                .thenReturn(Optional.of(mockSchedule));        when(scheduleRepository.isLastRemainingRepeatSchedule(repeatId))                .thenReturn(false);        ScheduleService spyScheduleService = spy(scheduleService);        doNothing().when(spyScheduleService).changeRepeatMasterScheduleId(userId, mockSchedule);        spyScheduleService.deleteCurrentOnlyRepeatSchedule(scheduleId, userId);        verify(spyScheduleService).changeRepeatMasterScheduleId(userId, mockSchedule);    }    @Test    void findById() {        when(scheduleRepository.findByIdAndUserId(mockSchedule.getId(), mockUser.getId()))                .thenReturn(Optional.of(mockSchedule));        Optional<ScheduleDto> result = scheduleService.findById(mockSchedule.getId(), mockSchedule.getUserId());        assertTrue(result.isPresent());        assertEquals(mockSchedule.getTitle(), result.get().getTitle());    }    @Test    void findAll() {        when(scheduleRepository.findAll()).thenReturn(List.of(mockSchedule));        List<ScheduleDto> result = scheduleService.findAll();        assertFalse(result.isEmpty());        assertEquals(mockSchedule.getTitle(), result.get(0).getTitle());    }    @Test    void findByUserId() {        when(scheduleRepository.findByUserId(mockUser.getId()))                .thenReturn(List.of(mockSchedule));        List<ScheduleDto> result = scheduleService.findByUserId(mockUser.getId());        ScheduleDto expectedSchedule = new ScheduleDto(mockSchedule);        assertThat(result)                .isNotEmpty()                .hasSize(1)                .usingRecursiveComparison()                .isEqualTo(List.of(expectedSchedule));    }    @ParameterizedTest    @CsvSource({            "true",  // Schedule이 존재할 때            "false"  // Schedule이 존재하지 않을 때    })    void existsById(boolean scheduleExists) {        // Given        when(scheduleRepository.existsById(mockSchedule.getId()))                .thenReturn(scheduleExists);        // When        Boolean hasSchedule = scheduleService.existsById(mockSchedule.getId());        // Then        assertThat(hasSchedule).isEqualTo(scheduleExists);    }    @Test    void getSchedulesByDateRange() {        List<ScheduleEntity> mockSchedules = List.of(mockSchedule);        when(scheduleRepository.findSchedules(mockSchedule.getStartAt(), mockSchedule.getEndAt(), mockUser.getId()))                .thenReturn(mockSchedules);        List<ScheduleDto> result = scheduleService.getSchedulesByDateRange(mockSchedule.getStartAt(), mockSchedule.getEndAt(), mockUser.getId());        ScheduleDto expectedSchedule = new ScheduleDto(mockSchedule);        assertThat(result)                .isNotEmpty()                .hasSize(1)                .usingRecursiveComparison()                .isEqualTo(List.of(expectedSchedule));    }    @Test    void testChangeRepeatMasterScheduleId_whenMasterIsSame_thenChangeMasterScheduleId() {        // Given        long userId = 1L;        long scheduleId = 10L;        long repeatId = 100L;        long newMasterId = 20L;        // 스케줄 엔티티 생성 (현재 스케줄)        ScheduleEntity scheduleEntity = new ScheduleEntity();        scheduleEntity.setId(scheduleId);        scheduleEntity.setRepeatId(repeatId);        scheduleEntity.setStartAt(LocalDateTime.of(2025, 3, 11, 10, 0));        // 반복 엔티티 생성 (현재 master 일정이 scheduleEntity의 id와 같은 경우)        ScheduleRepeatEntity repeatEntity = new ScheduleRepeatEntity();        repeatEntity.setMasterScheduleId(scheduleId);        // 미래 스케줄 생성        ScheduleEntity futureSchedule = new ScheduleEntity();        futureSchedule.setId(newMasterId);        // 반복 엔티티 조회 (여기서는 repeatId를 사용)        when(scheduleRepeatRepository.findById(repeatId))                .thenReturn(Optional.of(repeatEntity));        // 미래 스케줄 조회        when(scheduleRepository.findFutureRepeatSchedules(repeatId, scheduleEntity.getStartAt(), userId))                .thenReturn(List.of(futureSchedule));        // When        scheduleService.changeRepeatMasterScheduleId(userId, scheduleEntity);        // Then        assertEquals(newMasterId, repeatEntity.getMasterScheduleId());        verify(scheduleRepeatRepository).save(repeatEntity);    }}